import urllib.request
import urllib.parse
import urllib.error


TARGET = 'http://crypto-class.appspot.com/po?er='
CIPHER = 'f20bdba6ff29eed7b046d1df9fb7000058b1ffb4210a580f748b4ac714c001bd4a61044426fb515dad3f21f18aa577c0bdf302936266926ff37dbf7035d5eeb4'
BLOCKSIZE = 16

class PaddingOracle(type):
    """Questions oracle and returns validity of padding"""
    def query(self, q: str) -> bool:
        pass


class WebExamplePaddingOracle(metaclass=PaddingOracle):
    def query(self, q):
        target = TARGET + urllib.parse.quote(q)  # Create query URL
        req = urllib.request.Request(target)     # Send HTTP request to server
        try:
            f = urllib.request.urlopen(req)      # Wait for response
        except urllib.error.HTTPError as e:          
            if e.code == 404:
                return True # good padding
            return False # bad padding
        

class Attacker(object):
    def __init__(self, oracle: PaddingOracle, cipher: str = CIPHER, blocksize: int = BLOCKSIZE) -> None:
        self.oracle = oracle

        if(blocksize<=0): raise ValueError("Invalid blocksize, must be positive integer")
        else: self.blocksize = blocksize
        
        if(len(cipher) % blocksize*2 != 0): raise ValueError("Cipher must be of correct length (multiple of blocksize)")
        else: self.cipher = cipher


    def attack(self) -> str: #returns decoded ascii-String extracted from padding oracle
        cipher_bytearray = bytearray(bytes.fromhex(self.cipher))
        plaintext_bytearray = bytearray(len(cipher_bytearray)) # Buffer of zeroes for solutions
        
        for i in range(len(cipher_bytearray)//self.blocksize-1): # Iterate through all blocks to decipher (omit first block, it's the IV)
            fst_block = cipher_bytearray[self.blocksize*i:self.blocksize*(i+1)]
            snd_block = cipher_bytearray[self.blocksize*(i+1):self.blocksize*(i+2)]
            retrieved_block_plaintext = self.__attack_block(fst_block, snd_block) # Function uses first block to attack second block
            plaintext_bytearray[self.blocksize*(i+1):self.blocksize*(i+2)] = retrieved_block_plaintext

        plaintext_bytearray = plaintext_bytearray[self.blocksize:] # Omit leading zeroes from IV
        plaintext = plaintext_bytearray.decode('ascii')

        return plaintext


    def __attack_block(self, fst: bytearray, snd: bytearray) -> bytearray:
        if (len(fst) != self.blocksize): raise ValueError("Must pass whole blocks to function (first failed)")
        if (len(snd) != self.blocksize): raise ValueError("Must pass whole blocks to function (second failed)")

        #print(f"Started attacking blocks {fst.hex()} and {snd.hex()}")

        plaintext_bytearray = bytearray(self.blocksize) # Bytearray where found bytes will be stored

        for current_byte_idx in range(self.blocksize-1, -1, -1): # Decryption starts from the back
            pad_mask = self.__create_pad_mask(self.blocksize - current_byte_idx)
            print(f"trying byte {current_byte_idx} with solutions {plaintext_bytearray} and pad mask {pad_mask}")

            current_solution = 0
            for x in range(256): # Try all possible values a byte can have
                fst_mutable = fst.copy()
                fst_mutable[current_byte_idx] ^=  x # Inject guess
                fst_mutable = self.__xor_bytearrays(fst_mutable, pad_mask) # Use pad mask
                fst_mutable = self.__xor_bytearrays(fst_mutable, plaintext_bytearray) # Use earlier knowledge
                query = (fst_mutable + snd).hex() 
                
                pad_valid = self.oracle.query(query) 

                if(pad_valid):
                    current_solution = x #TODO: es könnten mehr bytes valid sein
                    print(f"found {x} at {current_byte_idx}")

            plaintext_bytearray[current_byte_idx] = current_solution
            print(f"finished byte {current_byte_idx} with {current_solution}")
        
        return plaintext_bytearray
    

    def __create_pad_mask(self, size: int) -> bytearray:
        #TODO: test ob gewünschte größe überhaupt sein kann
        mask = bytearray(self.blocksize)
        for i in range(size):
            mask[-i-1] = size
        return mask

    def __xor_bytearrays(self, bytearray1: bytearray, bytearray2: bytearray) -> bytearray:
        if len(bytearray1) != len(bytearray2):
            raise ValueError("Bytearrays must be of same length")

        result = bytearray(len(bytearray1))
        for i in range(len(bytearray1)):
            result[i] = bytearray1[i] ^ bytearray2[i] 
        return result


po = WebExamplePaddingOracle()
atk = Attacker(po, cipher = CIPHER, blocksize = BLOCKSIZE)
sol = atk.attack()
print(sol)
