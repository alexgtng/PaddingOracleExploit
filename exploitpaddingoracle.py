# Abstract superclass for usable oracles
class PaddingOracle(type):
    """Questions oracle and returns validity of padding"""
    def query(self, q: str) -> bool:
        pass

        

class Attacker(object):
    def __init__(self, oracle: PaddingOracle, cipher: str, blocksize: int = 16) -> None:
        self.oracle = oracle

        if(blocksize<=0): raise ValueError("Invalid blocksize, must be positive integer")
        else: self.blocksize = blocksize
        
        if(len(cipher) % blocksize*2 != 0): raise ValueError("Cipher must be of correct length (multiple of blocksize)")
        else: self.cipher = cipher


    def attack(self, v: bool = False) -> str: #returns decoded ascii-String extracted from padding oracle (v is verbose flag)
        cipher_bytearray = bytearray(bytes.fromhex(self.cipher))
        plaintext_bytearray = bytearray(len(cipher_bytearray)) # Buffer of zeroes for solutions
        
        for i in range(len(cipher_bytearray)//self.blocksize-1): # Iterate through all blocks to decipher (omit first block, it's the IV)
            if(v): print(f"Attacking block {i+1}")
            fst_block = cipher_bytearray[self.blocksize*i:self.blocksize*(i+1)]
            snd_block = cipher_bytearray[self.blocksize*(i+1):self.blocksize*(i+2)]
            retrieved_block_plaintext = self.__attack_block(fst_block, snd_block, v) # Function uses first block to attack second block
            plaintext_bytearray[self.blocksize*(i+1):self.blocksize*(i+2)] = retrieved_block_plaintext

        plaintext_bytearray = plaintext_bytearray[self.blocksize:] # Omit leading zeroes from IV
        plaintext = plaintext_bytearray.decode('ascii')
        if(v): print(f"Plaintext found: {plaintext}")

        return plaintext


    def __attack_block(self, fst: bytearray, snd: bytearray, v: bool = False) -> bytearray:
        if (len(fst) != self.blocksize): raise ValueError("Must pass whole blocks to function (first failed)")
        if (len(snd) != self.blocksize): raise ValueError("Must pass whole blocks to function (second failed)")

        plaintext_bytearray = bytearray(self.blocksize) # Bytearray where found bytes will be stored

        for current_byte_idx in range(self.blocksize-1, -1, -1): # Decryption starts from the back
            pad_mask = self.__create_pad_mask(self.blocksize - current_byte_idx)
            if(v): print(f"Trying byte {current_byte_idx} with solutions {plaintext_bytearray} and pad mask {pad_mask}")

            current_solution = 0
            for x in range(256): # Try all possible values a byte can have
                fst_mutable = fst.copy()
                fst_mutable[current_byte_idx] ^=  x # Inject guess
                fst_mutable = self.__xor_bytearrays(fst_mutable, pad_mask) # Use pad mask
                fst_mutable = self.__xor_bytearrays(fst_mutable, plaintext_bytearray) # Use earlier knowledge
                query = (fst_mutable + snd).hex() 
                
                pad_valid = self.oracle.query(query) 

                if(pad_valid):
                    current_solution = x #TODO: taking only the last of the possible bytes might not be the best option
                    if(v): print(f"Found {x} at {current_byte_idx}")

            plaintext_bytearray[current_byte_idx] = current_solution
            if(v): print(f"Finished byte {current_byte_idx} with {current_solution}")
        if(v): print(f"Finished block with {plaintext_bytearray}")
        
        return plaintext_bytearray
    

    def __create_pad_mask(self, size: int) -> bytearray:
        #TODO: test ob gewünschte größe überhaupt sein kann
        mask = bytearray(self.blocksize)
        for i in range(size):
            mask[-i-1] = size
        return mask

    def __xor_bytearrays(self, bytearray1: bytearray, bytearray2: bytearray) -> bytearray:
        if len(bytearray1) != len(bytearray2):
            raise ValueError("Bytearrays must be of same length")

        result = bytearray(len(bytearray1))
        for i in range(len(bytearray1)):
            result[i] = bytearray1[i] ^ bytearray2[i] 
        return result
